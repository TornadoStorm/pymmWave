"""
This type stub file was generated by pyright.
"""

import io
import time

def iterbytes(b):
    """Iterate over bytes, returning bytes instead of ints (python3)"""
    ...

def to_bytes(seq):
    """convert a sequence to a bytes type"""
    ...

XON = ...
XOFF = ...
CR = ...
LF = ...
PARITY_NAMES = ...
class SerialException(IOError):
    """Base class for serial port related exceptions."""
    ...


class SerialTimeoutException(SerialException):
    """Write timeouts give an exception"""
    ...


class PortNotOpenError(SerialException):
    """Port is not open"""
    def __init__(self) -> None:
        ...
    


class Timeout(object):
    """\
    Abstraction for timeout operations. Using time.monotonic() if available
    or time.time() in all other cases.

    The class can also be initialized with 0 or None, in order to support
    non-blocking and fully blocking I/O operations. The attributes
    is_non_blocking and is_infinite are set accordingly.
    """
    if hasattr(time, 'monotonic'):
        TIME = ...
    else:
        TIME = ...
    def __init__(self, duration) -> None:
        """Initialize a timeout with given duration"""
        ...
    
    def expired(self):
        """Return a boolean, telling if the timeout has expired"""
        ...
    
    def time_left(self):
        """Return how many seconds are left until the timeout expires"""
        ...
    
    def restart(self, duration):
        """\
        Restart a timeout, only supported if a timeout was already set up
        before.
        """
        ...
    


class SerialBase(io.RawIOBase):
    """\
    Serial port base class. Provides __init__ function and properties to
    get/set port settings.
    """
    BAUDRATES = ...
    BYTESIZES = ...
    PARITIES = ...
    STOPBITS = ...
    def __init__(self, port=..., baudrate=..., bytesize=..., parity=..., stopbits=..., timeout=..., xonxoff=..., rtscts=..., write_timeout=..., dsrdtr=..., inter_byte_timeout=..., exclusive=..., **kwargs) -> None:
        """\
        Initialize comm port object. If a "port" is given, then the port will be
        opened immediately. Otherwise a Serial port object in closed state
        is returned.
        """
        ...
    
    @property
    def port(self):
        """\
        Get the current port setting. The value that was passed on init or using
        setPort() is passed back.
        """
        ...
    
    @port.setter
    def port(self, port):
        """\
        Change the port.
        """
        ...
    
    @property
    def baudrate(self):
        """Get the current baud rate setting."""
        ...
    
    @baudrate.setter
    def baudrate(self, baudrate):
        """\
        Change baud rate. It raises a ValueError if the port is open and the
        baud rate is not possible. If the port is closed, then the value is
        accepted and the exception is raised when the port is opened.
        """
        ...
    
    @property
    def bytesize(self):
        """Get the current byte size setting."""
        ...
    
    @bytesize.setter
    def bytesize(self, bytesize):
        """Change byte size."""
        ...
    
    @property
    def exclusive(self):
        """Get the current exclusive access setting."""
        ...
    
    @exclusive.setter
    def exclusive(self, exclusive):
        """Change the exclusive access setting."""
        ...
    
    @property
    def parity(self):
        """Get the current parity setting."""
        ...
    
    @parity.setter
    def parity(self, parity):
        """Change parity setting."""
        ...
    
    @property
    def stopbits(self):
        """Get the current stop bits setting."""
        ...
    
    @stopbits.setter
    def stopbits(self, stopbits):
        """Change stop bits size."""
        ...
    
    @property
    def timeout(self):
        """Get the current timeout setting."""
        ...
    
    @timeout.setter
    def timeout(self, timeout):
        """Change timeout setting."""
        ...
    
    @property
    def write_timeout(self):
        """Get the current timeout setting."""
        ...
    
    @write_timeout.setter
    def write_timeout(self, timeout):
        """Change timeout setting."""
        ...
    
    @property
    def inter_byte_timeout(self):
        """Get the current inter-character timeout setting."""
        ...
    
    @inter_byte_timeout.setter
    def inter_byte_timeout(self, ic_timeout):
        """Change inter-byte timeout setting."""
        ...
    
    @property
    def xonxoff(self):
        """Get the current XON/XOFF setting."""
        ...
    
    @xonxoff.setter
    def xonxoff(self, xonxoff):
        """Change XON/XOFF setting."""
        ...
    
    @property
    def rtscts(self):
        """Get the current RTS/CTS flow control setting."""
        ...
    
    @rtscts.setter
    def rtscts(self, rtscts):
        """Change RTS/CTS flow control setting."""
        ...
    
    @property
    def dsrdtr(self):
        """Get the current DSR/DTR flow control setting."""
        ...
    
    @dsrdtr.setter
    def dsrdtr(self, dsrdtr=...):
        """Change DsrDtr flow control setting."""
        ...
    
    @property
    def rts(self):
        ...
    
    @rts.setter
    def rts(self, value):
        ...
    
    @property
    def dtr(self):
        ...
    
    @dtr.setter
    def dtr(self, value):
        ...
    
    @property
    def break_condition(self):
        ...
    
    @break_condition.setter
    def break_condition(self, value):
        ...
    
    @property
    def rs485_mode(self):
        """\
        Enable RS485 mode and apply new settings, set to None to disable.
        See serial.rs485.RS485Settings for more info about the value.
        """
        ...
    
    @rs485_mode.setter
    def rs485_mode(self, rs485_settings):
        ...
    
    _SAVED_SETTINGS = ...
    def get_settings(self):
        """\
        Get current port settings as a dictionary. For use with
        apply_settings().
        """
        ...
    
    def apply_settings(self, d):
        """\
        Apply stored settings from a dictionary returned from
        get_settings(). It's allowed to delete keys from the dictionary. These
        values will simply left unchanged.
        """
        ...
    
    def __repr__(self):
        """String representation of the current port settings and its state."""
        ...
    
    def readable(self):
        ...
    
    def writable(self):
        ...
    
    def seekable(self):
        ...
    
    def readinto(self, b):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *args, **kwargs):
        ...
    
    def send_break(self, duration=...):
        """\
        Send break condition. Timed, returns to idle state after given
        duration.
        """
        ...
    
    def flushInput(self):
        ...
    
    def flushOutput(self):
        ...
    
    def inWaiting(self):
        ...
    
    def sendBreak(self, duration=...):
        ...
    
    def setRTS(self, value=...):
        ...
    
    def setDTR(self, value=...):
        ...
    
    def getCTS(self):
        ...
    
    def getDSR(self):
        ...
    
    def getRI(self):
        ...
    
    def getCD(self):
        ...
    
    def setPort(self, port):
        ...
    
    @property
    def writeTimeout(self):
        ...
    
    @writeTimeout.setter
    def writeTimeout(self, timeout):
        ...
    
    @property
    def interCharTimeout(self):
        ...
    
    @interCharTimeout.setter
    def interCharTimeout(self, interCharTimeout):
        ...
    
    def getSettingsDict(self):
        ...
    
    def applySettingsDict(self, d):
        ...
    
    def isOpen(self):
        ...
    
    def read_all(self):
        """\
        Read all bytes currently available in the buffer of the OS.
        """
        ...
    
    def read_until(self, expected=..., size=...):
        """\
        Read until an expected sequence is found ('\n' by default), the size
        is exceeded or until timeout occurs.
        """
        ...
    
    def iread_until(self, *args, **kwargs):
        """\
        Read lines, implemented as generator. It will raise StopIteration on
        timeout (empty read).
        """
        ...
    


if __name__ == '__main__':
    s = ...
