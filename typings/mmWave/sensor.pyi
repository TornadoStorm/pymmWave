"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from typing import Optional
from .data_model import xyzd
from enum import Enum

class Sensor(ABC):
    """
    Base Sensor Class
    """
    class SensorType(Enum):
        """Enum class for sensor types
        """
        IMU = ...
        POINT_CLOUD3D = ...
        POINT_CLOUD2D = ...
    
    
    @abstractmethod
    def type(self) -> Sensor.SensorType:
        """Return the type of a sensor

        Returns:
            str: Type of sensor
        """
        ...
    
    @abstractmethod
    def model(self) -> str:
        """Return the model of a sensor

        Returns:
            str: Name of sensor
        """
        ...
    
    @abstractmethod
    def is_alive(self) -> bool:
        """Check if sensor is still alive

        Returns:
            bool: True if alive
        """
        ...
    
    @abstractmethod
    async def start_sensor(self) -> None:
        """While true loop that will start the sensor

        Returns:
            Nothing, will be run as a coroutine!
        """
        ...
    
    @abstractmethod
    def stop_sensor(self):
        """Stop sensor

        Returns:
            Nothing, kills everything
        """
        ...
    
    @abstractmethod
    async def get_data(self) -> xyzd:
        """Return data from sensor.
        """
        ...
    
    @abstractmethod
    def get_data_nowait(self) -> Optional[xyzd]:
        """Return data from sensor.
        """
        ...
    
    @abstractmethod
    def get_update_freq(self) -> float:
        """Return sensor update freq.
        """
        ...
    


class SpatialSensor(object):
    """Wrapper to provide the notion of a sensor in space
    TODO: It could be fun to make another class which si a similair wrapper and
        preprocesses data to be in the right orientation at point of usage
    """
    def __init__(self, sens: Sensor, location: tuple[float, float, float], pitch_rads: tuple[float, float, float]) -> None:
        ...
    


class InvalidSensorException(Exception):
    def __init__(self, message: str, errors) -> None:
        ...
    


if __name__ == "__main__":
    x = ...
