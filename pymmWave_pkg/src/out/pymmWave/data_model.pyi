import abc
import numpy as np
from abc import ABC, abstractmethod
from scipy.spatial.transform.rotation import Rotation
from typing import Any

class DataModel(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def get(self) -> Any: ...

class DopplerPointCloud(DataModel):
    def __init__(self, data: np.ndarray) -> None: ...
    def get(self) -> np.ndarray: ...
    def translate_rotate(self, location: tuple[float, float, float], pitch_rads: Rotation) -> Any: ...
    def append(self, other: DopplerPointCloud) -> bool: ...
    def __eq__(self, o: object) -> bool: ...

class ImuVelocityData(DataModel):
    def __init__(self, dxdydz: tuple[float, float, float], drolldpitchdyaw: tuple[float, float, float]) -> None: ...
    def get(self) -> Rotation: ...
    def get_dxdydz(self) -> tuple[float, float, float]: ...
    def get_drolldpitchdyaw(self) -> tuple[float, float, float]: ...

class ImuData(DataModel):
    def __init__(self, altitude: float, dxdydz: tuple[float, float, float], drolldpitchdyaw: tuple[float, float, float], heading: float) -> None: ...
    def get(self) -> Rotation: ...
    def get_altitude(self) -> float: ...
    def get_heading(self) -> float: ...
    def get_dxdydz(self) -> tuple[float, float, float]: ...
    def get_drolldpitchdyaw(self) -> tuple[float, float, float]: ...

class _speed_constraints(DataModel, metaclass=abc.ABCMeta):
    def __init__(self, max_x: tuple[float, float], max_y: tuple[float, float], max_z: tuple[float, float]) -> None: ...
    def get_max_x(self) -> tuple[float, float]: ...
    def get_max_y(self) -> tuple[float, float]: ...
    def get_max_z(self) -> tuple[float, float]: ...

class Pose(DataModel):
    def __init__(self) -> None: ...
    def move(self, imu_vel: ImuVelocityData, time_passed: float) -> Any: ...
    def get(self) -> tuple[float, float, float, float, float, float]: ...
