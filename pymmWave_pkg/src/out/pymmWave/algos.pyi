import abc
from .data_model import DopplerPointCloud as DopplerPointCloud, ImuVelocityData as ImuVelocityData, Pose as Pose
from .logging import Logger as Logger, StdOutLogger as StdOutLogger
from abc import ABC, abstractmethod
from typing import Any, Optional

class Algorithm(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    @abstractmethod
    def reset(self) -> None: ...
    def set_logger(self, new_logger: Logger) -> Any: ...
    def log(self, *args: Any, **kwargs: Any) -> None: ...
    def error(self, *args: Any, **kwargs: Any) -> None: ...

class SimpleMeanDistance(Algorithm):
    def __init__(self) -> None: ...
    def run(self, input: DopplerPointCloud) -> float: ...
    def reset(self) -> None: ...

class IMUAdjustedPersistedData(Algorithm):
    def __init__(self, steps_to_persist: int) -> None: ...
    def reset(self) -> None: ...
    def change_persisted_steps(self, new_steps: int) -> bool: ...
    def run(self, input_cloud: DopplerPointCloud, imu_in: ImuVelocityData) -> DopplerPointCloud: ...

class CloudEstimatedIMU(Algorithm):
    def __init__(self) -> None: ...
    def modify_minimum_datapoints(self, val: int) -> None: ...
    def run(self, data: DopplerPointCloud) -> Optional[ImuVelocityData]: ...
    def reset(self) -> None: ...

class EstimatedRelativePosition(Algorithm):
    def __init__(self) -> None: ...
    def run(self, imu_vel: ImuVelocityData, t_factor: float=..., is_moving: bool=...) -> Pose: ...
    def reset(self) -> None: ...
